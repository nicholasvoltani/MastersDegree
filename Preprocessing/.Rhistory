library(stringr)
library(readr)
DATA_INPUT_PATH = "C:/Users/nicho/Documents/MastersDegree/DataInputs/"
FILE_PATH = "C:/Users/nicho/Documents/MastersDegree/DataInputs/EIA_International_Production_251112.csv"
# Define the regex pattern for the separator line.
# Based on your request: "",total*\n
# ^      -> Start of the line
# \"\"   -> A literal "" (quotes are escaped with \)
# ,total -> A literal ,total
# .* -> Any character, zero or more times (your "*" placeholder)
# $      -> End of the line
separator_pattern <- "^\"\",\"total.*$"
input_file = FILE_PATH
# Read the entire file as individual lines
all_lines <- readLines(input_file)
# Header is in second line: '''API, "", 1980, ...'''
header <- all_lines[2]
header <- new_string <- str_replace(header, '\"\"', '\"Region\"')
all_lines <- all_lines[3:length(all_lines)]
# --- 3. Identify and Group Chunks ---
# Create a logical vector (TRUE/FALSE) where TRUE means the line is a separator
is_separator <- grepl(separator_pattern, all_lines)
# We need to create a grouping ID for each chunk.
# A new chunk starts on the line *after* a separator line.
# We shift the `is_separator` vector by one and add `TRUE` at the
# beginning, because the very first line always starts a new chunk.
is_new_group_start <- c(TRUE, is_separator[-length(is_separator)])
# By taking the cumulative sum, we create a unique ID for each group.
# All lines in the first chunk get "1", the second chunk "2", etc.
group_id <- cumsum(is_new_group_start)
# Split the lines into a list of chunks based on the group ID
line_chunks <- split(all_lines, group_id)
all_lines[1:4]
all_lines[which(is_separator),]
all_lines[which(is_separator)]
separator_pattern
totals <- gsub('^"",\"(total[^\"]*)\".*$', '\\1', all_lines[is_separator], perl = TRUE)
totals
names(line_chunks)
for (id in names(line_chunks)){print(totals[id])}
for (id in names(line_chunks)){print(totals[[id]])}
for (id in names(line_chunks)){print(totals[numeric(id)])}
